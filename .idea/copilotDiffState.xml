<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/client/src/components/Octahedron.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/components/Octahedron.tsx" />
              <option name="originalContent" value="import { useRef, useState, useEffect, useMemo } from &quot;react&quot;;&#10;import { useFrame, useThree } from &quot;@react-three/fiber&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;import { Mesh } from &quot;three&quot;;&#10;import { Line2 } from &quot;three/examples/jsm/lines/Line2.js&quot;;&#10;import { LineGeometry } from &quot;three/examples/jsm/lines/LineGeometry.js&quot;;&#10;import { LineMaterial } from &quot;three/examples/jsm/lines/LineMaterial.js&quot;;&#10;import OctahedronRegion from &quot;./OctahedronRegion&quot;;&#10;&#10;export default function Octahedron({ regionDetails = [5,5,5,5,5,5,5,5] }: { regionDetails?: number[] }) {&#10;  // Refs&#10;  const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;  const meshRefs = useRef&lt;(Mesh | null)[]&gt;([]);&#10;  const lineRef = useRef&lt;Line2 | null&gt;(null);&#10;  const { camera, raycaster, pointer } = useThree();&#10;&#10;  // State declarations&#10;  const [hovered, setHovered] = useState(false);&#10;  const [clickedTriangles, setClickedTriangles] = useState&lt;Set&lt;number&gt;&gt;(new Set());&#10;  const [selectionMode, setSelectionMode] = useState(false);&#10;  const [hoveredTriangle, setHoveredTriangle] = useState&lt;number | null&gt;(null);&#10;&#10;  // Octahedron base vertices&#10;  const baseVerts = [&#10;    new THREE.Vector3(1, 0, 0),&#10;    new THREE.Vector3(-1, 0, 0),&#10;    new THREE.Vector3(0, 1, 0),&#10;    new THREE.Vector3(0, -1, 0),&#10;    new THREE.Vector3(0, 0, 1),&#10;    new THREE.Vector3(0, 0, -1),&#10;  ];&#10;&#10;  // 8 faces, each as 3 indices into baseVerts&#10;  const faces = [&#10;    [0, 2, 4], [2, 1, 4], [1, 3, 4], [3, 0, 4],&#10;    [0, 5, 2], [2, 5, 1], [1, 5, 3], [3, 5, 0],&#10;  ];&#10;&#10;  // Handler for triangle click&#10;  function handleTriangleClick(triangleIndex: number) {&#10;    console.log(`[${new Date().toLocaleTimeString()}] handleTriangleClick: triangleIndex=`, triangleIndex);&#10;    setClickedTriangles((prev) =&gt; {&#10;      if (prev.has(triangleIndex)) return new Set();&#10;      return new Set([triangleIndex]);&#10;    });&#10;    setSelectionMode(false);&#10;  }&#10;&#10;  // Subdivide a triangle into 4 smaller triangles&#10;  const subdivideTriangle = (&#10;    v1: THREE.Vector3,&#10;    v2: THREE.Vector3,&#10;    v3: THREE.Vector3,&#10;    level: number,&#10;  ): THREE.Vector3[][] =&gt; {&#10;    if (level === 0) {&#10;      return [[v1, v2, v3]];&#10;    }&#10;&#10;    // Calculate midpoints and normalize to sphere surface&#10;    const m1 = new THREE.Vector3()&#10;      .addVectors(v1, v2)&#10;      .multiplyScalar(0.5)&#10;      .normalize()&#10;      .multiplyScalar(2);&#10;    const m2 = new THREE.Vector3()&#10;      .addVectors(v2, v3)&#10;      .multiplyScalar(0.5)&#10;      .normalize()&#10;      .multiplyScalar(2);&#10;    const m3 = new THREE.Vector3()&#10;      .addVectors(v3, v1)&#10;      .multiplyScalar(0.5)&#10;      .normalize()&#10;      .multiplyScalar(2);&#10;&#10;    // Recursively subdivide the 4 sub-triangles&#10;    return [&#10;      ...subdivideTriangle(v1, m1, m3, level - 1),&#10;      ...subdivideTriangle(m1, v2, m2, level - 1),&#10;      ...subdivideTriangle(m3, m2, v3, level - 1),&#10;      ...subdivideTriangle(m1, m2, m3, level - 1),&#10;    ];&#10;  };&#10;&#10;  // Create individual triangle geometries for each face&#10;  const createOctahedronTriangles = () =&gt; {&#10;    console.log(`[${new Date().toLocaleTimeString()}] Creating octahedron triangles...`);&#10;&#10;    const baseOctahedron = new THREE.OctahedronGeometry(2, 0);&#10;    const positions = baseOctahedron.attributes.position.array as Float32Array;&#10;    const indices = baseOctahedron.index?.array as Uint16Array;&#10;&#10;    console.log(`[${new Date().toLocaleTimeString()}] Base octahedron created:`, {&#10;      positionsLength: positions.length,&#10;      indicesLength: indices?.length,&#10;      hasIndices: !!indices,&#10;    });&#10;&#10;    const allTriangles: { geometry: THREE.BufferGeometry; index: number }[] =&#10;      [];&#10;    let triangleIndex = 0;&#10;&#10;    // Handle both indexed and non-indexed geometries&#10;    const faceCount = indices ? indices.length / 3 : positions.length / 9;&#10;&#10;    // Process each face of the base octahedron&#10;    for (let i = 0; i &lt; faceCount; i++) {&#10;      let v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3;&#10;&#10;      if (indices) {&#10;        // Use indices to get vertices&#10;        const [i1, i2, i3] = [indices[i * 3], indices[i * 3 + 1], indices[i * 3 + 2]];&#10;        v1 = new THREE.Vector3().fromArray(positions, i1 * 3);&#10;        v2 = new THREE.Vector3().fromArray(positions, i2 * 3);&#10;        v3 = new THREE.Vector3().fromArray(positions, i3 * 3);&#10;      } else {&#10;        // Use direct position data&#10;        const startIndex = i * 9;&#10;        v1 = new THREE.Vector3().fromArray(positions, startIndex);&#10;        v2 = new THREE.Vector3().fromArray(positions, startIndex + 3);&#10;        v3 = new THREE.Vector3().fromArray(positions, startIndex + 6);&#10;      }&#10;&#10;      // Use maximum detail level from regionDetails for initial geometry creation&#10;      const maxDetail = Math.max(...regionDetails);&#10;      const subdivided = subdivideTriangle(v1, v2, v3, maxDetail);&#10;&#10;      subdivided.forEach((triangle) =&gt; {&#10;        const geometry = new THREE.BufferGeometry();&#10;        const positions = triangle.flatMap(v =&gt; [v.x, v.y, v.z]);&#10;        geometry.setAttribute(&#10;          &quot;position&quot;,&#10;          new THREE.BufferAttribute(new Float32Array(positions), 3),&#10;        );&#10;        geometry.computeVertexNormals();&#10;&#10;        allTriangles.push({ geometry, index: triangleIndex++ });&#10;      });&#10;    }&#10;&#10;    console.log(`[${new Date().toLocaleTimeString()}] Created ${allTriangles.length} total triangles`);&#10;    return allTriangles;&#10;  };&#10;&#10;  // Memoize triangles to avoid unnecessary recalculation&#10;  const triangles = useMemo(() =&gt; {&#10;    const tris = createOctahedronTriangles();&#10;    console.log(`[${new Date().toLocaleTimeString()}] triangles useMemo: count=`, tris.length);&#10;    return tris;&#10;  }, [regionDetails]);&#10;&#10;  // Calculate triangle adjacency for keyboard navigation (optimized)&#10;  const triangleAdjacency = useMemo(() =&gt; {&#10;    console.log(`[${new Date().toLocaleTimeString()}] triangleAdjacency useMemo: triangles.length=`, triangles.length);&#10;    // Helper to create a unique key for an edge (sorted vertex positions)&#10;    function edgeKey(a: number[], b: number[]) {&#10;      // Sort the two vertices lexicographically&#10;      const v1 = a.join(&quot;,&quot;);&#10;      const v2 = b.join(&quot;,&quot;);&#10;      return v1 &lt; v2 ? `${v1}|${v2}` : `${v2}|${v1}`;&#10;    }&#10;&#10;    // Build a map from edge key to triangle indices&#10;    const edgeMap = new Map&lt;string, number[]&gt;();&#10;    triangles.forEach(({ geometry }, triIdx) =&gt; {&#10;      const pos = geometry.attributes.position.array as Float32Array;&#10;      const verts = [&#10;        [pos[0], pos[1], pos[2]],&#10;        [pos[3], pos[4], pos[5]],&#10;        [pos[6], pos[7], pos[8]],&#10;      ];&#10;      // Each triangle has 3 edges&#10;      for (let i = 0; i &lt; 3; i++) {&#10;        const a = verts[i];&#10;        const b = verts[(i + 1) % 3];&#10;        const key = edgeKey(a, b);&#10;        if (!edgeMap.has(key)) edgeMap.set(key, []);&#10;        edgeMap.get(key)!.push(triIdx);&#10;      }&#10;    });&#10;&#10;    // Now, for each triangle, find neighbors (other triangles sharing an edge)&#10;    const adjacency = new Map&lt;number, number&gt;();&#10;    triangles.forEach(({ geometry }, triIdx) =&gt; {&#10;      const pos = geometry.attributes.position.array as Float32Array;&#10;      const verts = [&#10;        [pos[0], pos[1], pos[2]],&#10;        [pos[3], pos[4], pos[5]],&#10;        [pos[6], pos[7], pos[8]],&#10;      ];&#10;      const neighbors = new Set&lt;number&gt;();&#10;      for (let i = 0; i &lt; 3; i++) {&#10;        const a = verts[i];&#10;        const b = verts[(i + 1) % 3];&#10;        const key = edgeKey(a, b);&#10;        const tris = edgeMap.get(key)!;&#10;        tris.forEach(idx =&gt; {&#10;          if (idx !== triIdx) neighbors.add(idx);&#10;        });&#10;      }&#10;      adjacency.set(triIdx, Array.from(neighbors));&#10;    });&#10;    console.log(`[${new Date().toLocaleTimeString()}] Adjacency map created with ${adjacency.size} entries`);&#10;    return adjacency;&#10;  }, [triangles]);&#10;&#10;  // Helper function to check if two triangles share an edge (2 vertices)&#10;  function shareEdge(&#10;    tri1: THREE.BufferGeometry,&#10;    tri2: THREE.BufferGeometry,&#10;  ): boolean {&#10;    const pos1 = tri1.attributes.position.array as Float32Array;&#10;    const pos2 = tri2.attributes.position.array as Float32Array;&#10;&#10;    const vertices1 = [];&#10;    const vertices2 = [];&#10;&#10;    // Extract vertices from both triangles&#10;    for (let i = 0; i &lt; 9; i += 3) {&#10;      vertices1.push([pos1[i], pos1[i + 1], pos1[i + 2]]);&#10;      vertices2.push([pos2[i], pos2[i + 1], pos2[i + 2]]);&#10;    }&#10;&#10;    // Count shared vertices (vertices that are very close to each other)&#10;    let sharedVertices = 0;&#10;    const tolerance = 0.001;&#10;&#10;    for (const v1 of vertices1) {&#10;      for (const v2 of vertices2) {&#10;        const dx = Math.abs(v1[0] - v2[0]);&#10;        const dy = Math.abs(v1[1] - v2[1]);&#10;        const dz = Math.abs(v1[2] - v2[2]);&#10;&#10;        if (dx &lt; tolerance &amp;&amp; dy &lt; tolerance &amp;&amp; dz &lt; tolerance) {&#10;          sharedVertices++;&#10;          break; // Found a match, move to next vertex in vertices1&#10;        }&#10;      }&#10;    }&#10;&#10;    // Triangles share an edge if they have exactly 2 vertices in common&#10;    return sharedVertices === 2;&#10;  }&#10;&#10;  // Keyboard navigation and G key mode&#10;  useEffect(() =&gt; {&#10;    const handleKeyDown = (event: KeyboardEvent) =&gt; {&#10;      // Handle G key for selection mode toggle&#10;      if (event.key === 'g' || event.key === 'G') {&#10;        const selectedTriangles = Array.from(clickedTriangles);&#10;        if (selectedTriangles.length === 1) {&#10;          setSelectionMode(!selectionMode);&#10;          setHoveredTriangle(null); // Clear any hover when toggling&#10;          console.log(`Selection mode ${!selectionMode ? 'enabled' : 'disabled'} [${new Date().toLocaleTimeString()}]`);&#10;          event.preventDefault();&#10;          return;&#10;        }&#10;      }&#10;&#10;      // Only handle navigation if a triangle is selected and not in selection mode&#10;      if (selectionMode) return;&#10;&#10;      const selectedTriangles = Array.from(clickedTriangles);&#10;      if (selectedTriangles.length !== 1) return;&#10;&#10;      const currentTriangle = selectedTriangles[0];&#10;      const neighbors = triangleAdjacency.get(currentTriangle) || [];&#10;&#10;      if (neighbors.length === 0) return;&#10;&#10;      let nextTriangle: number | null = null;&#10;&#10;      // Since each triangle has exactly 3 neighbors, map keys to cycle through them&#10;      switch (event.key) {&#10;        case &quot;ArrowUp&quot;:&#10;        case &quot;w&quot;:&#10;        case &quot;W&quot;:&#10;          // Move to first neighbor&#10;          nextTriangle = neighbors[0];&#10;          break;&#10;        case &quot;ArrowDown&quot;:&#10;        case &quot;s&quot;:&#10;        case &quot;S&quot;:&#10;          // Move to second neighbor (if available)&#10;          nextTriangle =&#10;            neighbors[1] !== undefined ? neighbors[1] : neighbors[0];&#10;          break;&#10;        case &quot;ArrowLeft&quot;:&#10;        case &quot;a&quot;:&#10;        case &quot;A&quot;:&#10;          // Move to third neighbor (cycling back)&#10;          nextTriangle =&#10;            neighbors[2] !== undefined&#10;              ? neighbors[2]&#10;              : neighbors[neighbors.length - 1];&#10;          break;&#10;        case &quot;ArrowRight&quot;:&#10;        case &quot;d&quot;:&#10;        case &quot;D&quot;:&#10;          // Cycle forward through neighbors (1 -&gt; 2 -&gt; 0 -&gt; 1...)&#10;          const currentIndex = neighbors.indexOf(currentTriangle);&#10;          let nextIndex = 0; // Default to first neighbor&#10;          if (currentIndex === -1) {&#10;            // If current triangle isn't in neighbors (shouldn't happen), use first neighbor&#10;            nextIndex = 0;&#10;          } else {&#10;            // Find which neighbor we came from and move to the next one&#10;            nextIndex =&#10;              neighbors.indexOf(&#10;                neighbors.find((n) =&gt; n &gt; currentTriangle) || neighbors[0],&#10;              ) % neighbors.length;&#10;          }&#10;          nextTriangle = neighbors[nextIndex];&#10;          break;&#10;        default:&#10;          return;&#10;      }&#10;&#10;      if (nextTriangle !== null) {&#10;        event.preventDefault();&#10;        console.log(&#10;          `[${new Date().toLocaleTimeString()}] Keyboard navigation: moving from triangle ${currentTriangle} to ${nextTriangle}`,&#10;        );&#10;        setClickedTriangles(new Set([nextTriangle]));&#10;      }&#10;    };&#10;&#10;    window.addEventListener(&quot;keydown&quot;, handleKeyDown);&#10;    return () =&gt; window.removeEventListener(&quot;keydown&quot;, handleKeyDown);&#10;  }, [clickedTriangles, triangleAdjacency, selectionMode]);&#10;&#10;  // Handle clicks on the group (background)&#10;  const handleClick = (event: THREE.Event) =&gt; {&#10;    // Disable selection mode when clicking anywhere&#10;    if (selectionMode) {&#10;      console.log('Disabling selection mode due to click [' + new Date().toLocaleTimeString() + ']');&#10;      setSelectionMode(false);&#10;    }&#10;  };&#10;&#10;  // Calculate triangle centers for pathfinding&#10;  const triangleCenters = useMemo(() =&gt; {&#10;    const centers = new Map&lt;number, THREE.Vector3&gt;();&#10;    triangles.forEach(({ geometry, index }) =&gt; {&#10;      const positions = geometry.attributes.position.array as Float32Array;&#10;      const center = new THREE.Vector3(&#10;        (positions[0] + positions[3] + positions[6]) / 3,&#10;        (positions[1] + positions[4] + positions[7]) / 3,&#10;        (positions[2] + positions[5] + positions[8]) / 3&#10;      );&#10;      centers.set(index, center);&#10;    });&#10;    return centers;&#10;  }, [triangles]);&#10;&#10;  // Pathfinding using BFS to find shortest path between triangles&#10;  const findPath = (start: number, end: number): number[] =&gt; {&#10;    if (start === end) return [start];&#10;&#10;    const queue: { triangle: number; path: number[] }[] = [{ triangle: start, path: [start] }];&#10;    const visited = new Set&lt;number&gt;([start]);&#10;&#10;    while (queue.length &gt; 0) {&#10;      const { triangle, path } = queue.shift()!;&#10;      const neighbors = triangleAdjacency.get(triangle) || [];&#10;&#10;      for (const neighbor of neighbors) {&#10;        if (neighbor === end) {&#10;          return [...path, neighbor];&#10;        }&#10;&#10;        if (!visited.has(neighbor)) {&#10;          visited.add(neighbor);&#10;          queue.push({ triangle: neighbor, path: [...path, neighbor] });&#10;        }&#10;      }&#10;    }&#10;&#10;    return []; // No path found&#10;  };&#10;&#10;  // Calculate path when in selection mode and hovering&#10;  const currentPath = useMemo(() =&gt; {&#10;    if (!selectionMode || hoveredTriangle === null) {&#10;      console.log(&quot;No path calculation - selectionMode:&quot;, selectionMode, &quot;hoveredTriangle:&quot;, hoveredTriangle);&#10;      return [];&#10;    }&#10;&#10;    const selectedTriangles = Array.from(clickedTriangles);&#10;    if (selectedTriangles.length !== 1) {&#10;      console.log(&quot;No path calculation - wrong selection count:&quot;, selectedTriangles.length);&#10;      return [];&#10;    }&#10;&#10;    const startTriangle = selectedTriangles[0];&#10;    if (startTriangle === hoveredTriangle) {&#10;      console.log(&quot;No path calculation - same triangle&quot;);&#10;      return [];&#10;    }&#10;&#10;    const path = findPath(startTriangle, hoveredTriangle);&#10;//     console.log(`Path calculated from ${startTriangle} to ${hoveredTriangle}:`, path);&#10;    return path;&#10;  }, [selectionMode, hoveredTriangle, clickedTriangles, triangleAdjacency]);&#10;&#10;  // Apply cursor style to canvas when in selection mode&#10;  useEffect(() =&gt; {&#10;    const canvas = document.querySelector('canvas');&#10;    if (canvas) {&#10;      canvas.style.cursor = selectionMode ? 'crosshair' : 'default';&#10;    }&#10;  }, [selectionMode]);&#10;&#10;  // Update line material resolution when window is resized&#10;  useEffect(() =&gt; {&#10;    const handleResize = () =&gt; {&#10;      if (lineRef.current &amp;&amp; lineRef.current.material) {&#10;        (lineRef.current.material as LineMaterial).resolution.set(&#10;          window.innerWidth, &#10;          window.innerHeight&#10;        );&#10;      }&#10;    };&#10;&#10;    window.addEventListener('resize', handleResize);&#10;    return () =&gt; {&#10;      window.removeEventListener('resize', handleResize);&#10;    };&#10;  }, []);&#10;&#10;  // Memoize path rendering function&#10;  const renderPath = useMemo(() =&gt; {&#10;    if (!selectionMode || hoveredTriangle === null || clickedTriangles.size !== 1) {&#10;      return null;&#10;    }&#10;&#10;    const selectedTriangle = Array.from(clickedTriangles)[0];&#10;    const path = findPath(selectedTriangle, hoveredTriangle);&#10;&#10;    if (path.length &gt; 1) {&#10;      const pathPoints = path.map(triangleIndex =&gt; {&#10;        const center = triangleCenters.get(triangleIndex);&#10;        return center ? center.clone().normalize().multiplyScalar(2.05) : new THREE.Vector3(0, 0, 0);&#10;      });&#10;&#10;      const positions: number[] = [];&#10;      pathPoints.forEach(point =&gt; {&#10;        positions.push(point.x, point.y, point.z);&#10;      });&#10;&#10;      const geometry = new LineGeometry();&#10;      geometry.setPositions(positions);&#10;&#10;      return (&#10;        &lt;primitive&#10;          object={new Line2(geometry,&#10;            new LineMaterial({&#10;              color: &quot;#ff4444&quot;,&#10;              linewidth: 3,&#10;              resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)&#10;            })&#10;          )}&#10;          ref={lineRef}&#10;        /&gt;&#10;      );&#10;    }&#10;    return null;&#10;  }, [selectionMode, hoveredTriangle, clickedTriangles, triangleCenters, findPath]);&#10;&#10;  return (&#10;    &lt;group&#10;      ref={groupRef}&#10;      position={[0, 0, 0]}&#10;      onClick={handleClick}&#10;      onPointerOver={() =&gt; setHovered(true)}&#10;      onPointerOut={() =&gt; setHovered(false)}&#10;    &gt;&#10;      {renderPath}&#10;&#10;      {faces.map((face, i) =&gt; (&#10;        &lt;OctahedronRegion&#10;          key={i}&#10;          baseVertices={[baseVerts[face[0]], baseVerts[face[1]], baseVerts[face[2]]]}&#10;          detail={regionDetails[i] || 0}&#10;          regionIndex={i}&#10;          onTriangleClick={(idx) =&gt; {&#10;            console.log(`[${new Date().toLocaleTimeString()}] OctahedronRegion onTriangleClick: regionIndex=`, i, 'triangleIndex=', idx);&#10;            handleTriangleClick(idx);&#10;          }}&#10;          selectedTriangles={clickedTriangles}&#10;          selectionMode={selectionMode}&#10;          hoveredTriangle={hoveredTriangle}&#10;          setHoveredTriangle={setHoveredTriangle}&#10;        /&gt;&#10;      ))}&#10;    &lt;/group&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import { useRef, useState, useEffect, useMemo } from &quot;react&quot;;&#10;import { useFrame, useThree } from &quot;@react-three/fiber&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;import { Mesh } from &quot;three&quot;;&#10;import { Line2 } from &quot;three/examples/jsm/lines/Line2.js&quot;;&#10;import { LineGeometry } from &quot;three/examples/jsm/lines/LineGeometry.js&quot;;&#10;import { LineMaterial } from &quot;three/examples/jsm/lines/LineMaterial.js&quot;;&#10;import OctahedronRegion from &quot;./OctahedronRegion&quot;;&#10;&#10;export default function Octahedron({ regionDetails = [5,5,5,5,5,5,5,5] }: { regionDetails?: number[] }) {&#10;  // Refs&#10;  const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;  const meshRefs = useRef&lt;(Mesh | null)[]&gt;([]);&#10;  const lineRef = useRef&lt;Line2 | null&gt;(null);&#10;  const { camera, raycaster, pointer } = useThree();&#10;&#10;  // State declarations&#10;  const [hovered, setHovered] = useState(false);&#10;  const [clickedTriangles, setClickedTriangles] = useState&lt;Set&lt;number&gt;&gt;(new Set());&#10;  const [selectionMode, setSelectionMode] = useState(false);&#10;  const [hoveredTriangle, setHoveredTriangle] = useState&lt;number | null&gt;(null);&#10;&#10;  // Octahedron base vertices&#10;  const baseVerts = [&#10;    new THREE.Vector3(1, 0, 0),&#10;    new THREE.Vector3(-1, 0, 0),&#10;    new THREE.Vector3(0, 1, 0),&#10;    new THREE.Vector3(0, -1, 0),&#10;    new THREE.Vector3(0, 0, 1),&#10;    new THREE.Vector3(0, 0, -1),&#10;  ];&#10;&#10;  // 8 faces, each as 3 indices into baseVerts&#10;  const faces = [&#10;    [0, 2, 4], [2, 1, 4], [1, 3, 4], [3, 0, 4],&#10;    [0, 5, 2], [2, 5, 1], [1, 5, 3], [3, 5, 0],&#10;  ];&#10;&#10;  // Handler for triangle click&#10;  function handleTriangleClick(triangleIndex: number) {&#10;    console.log(`[${new Date().toLocaleTimeString()}] handleTriangleClick: triangleIndex=`, triangleIndex);&#10;    setClickedTriangles((prev) =&gt; {&#10;      if (prev.has(triangleIndex)) return new Set();&#10;      return new Set([triangleIndex]);&#10;    });&#10;    setSelectionMode(false);&#10;  }&#10;&#10;  // Subdivide a triangle into 4 smaller triangles&#10;  const subdivideTriangle = (&#10;    v1: THREE.Vector3,&#10;    v2: THREE.Vector3,&#10;    v3: THREE.Vector3,&#10;    level: number,&#10;  ): THREE.Vector3[][] =&gt; {&#10;    if (level === 0) {&#10;      return [[v1, v2, v3]];&#10;    }&#10;&#10;    // Calculate midpoints and normalize to sphere surface&#10;    const m1 = new THREE.Vector3()&#10;      .addVectors(v1, v2)&#10;      .multiplyScalar(0.5)&#10;      .normalize()&#10;      .multiplyScalar(2);&#10;    const m2 = new THREE.Vector3()&#10;      .addVectors(v2, v3)&#10;      .multiplyScalar(0.5)&#10;      .normalize()&#10;      .multiplyScalar(2);&#10;    const m3 = new THREE.Vector3()&#10;      .addVectors(v3, v1)&#10;      .multiplyScalar(0.5)&#10;      .normalize()&#10;      .multiplyScalar(2);&#10;&#10;    // Recursively subdivide the 4 sub-triangles&#10;    return [&#10;      ...subdivideTriangle(v1, m1, m3, level - 1),&#10;      ...subdivideTriangle(m1, v2, m2, level - 1),&#10;      ...subdivideTriangle(m3, m2, v3, level - 1),&#10;      ...subdivideTriangle(m1, m2, m3, level - 1),&#10;    ];&#10;  };&#10;&#10;  // Create individual triangle geometries for each face&#10;  const createOctahedronTriangles = () =&gt; {&#10;    console.log(`[${new Date().toLocaleTimeString()}] Creating octahedron triangles...`);&#10;&#10;    const baseOctahedron = new THREE.OctahedronGeometry(2, 0);&#10;    const positions = baseOctahedron.attributes.position.array as Float32Array;&#10;    const indices = baseOctahedron.index?.array as Uint16Array;&#10;&#10;    console.log(`[${new Date().toLocaleTimeString()}] Base octahedron created:`, {&#10;      positionsLength: positions.length,&#10;      indicesLength: indices?.length,&#10;      hasIndices: !!indices,&#10;    });&#10;&#10;    const allTriangles: { geometry: THREE.BufferGeometry; index: number }[] =&#10;      [];&#10;    let triangleIndex = 0;&#10;&#10;    // Handle both indexed and non-indexed geometries&#10;    const faceCount = indices ? indices.length / 3 : positions.length / 9;&#10;&#10;    // Process each face of the base octahedron&#10;    for (let i = 0; i &lt; faceCount; i++) {&#10;      let v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3;&#10;&#10;      if (indices) {&#10;        // Use indices to get vertices&#10;        const [i1, i2, i3] = [indices[i * 3], indices[i * 3 + 1], indices[i * 3 + 2]];&#10;        v1 = new THREE.Vector3().fromArray(positions, i1 * 3);&#10;        v2 = new THREE.Vector3().fromArray(positions, i2 * 3);&#10;        v3 = new THREE.Vector3().fromArray(positions, i3 * 3);&#10;      } else {&#10;        // Use direct position data&#10;        const startIndex = i * 9;&#10;        v1 = new THREE.Vector3().fromArray(positions, startIndex);&#10;        v2 = new THREE.Vector3().fromArray(positions, startIndex + 3);&#10;        v3 = new THREE.Vector3().fromArray(positions, startIndex + 6);&#10;      }&#10;&#10;      // Use maximum detail level from regionDetails for initial geometry creation&#10;      const maxDetail = Math.max(...regionDetails);&#10;      const subdivided = subdivideTriangle(v1, v2, v3, maxDetail);&#10;&#10;      subdivided.forEach((triangle) =&gt; {&#10;        const geometry = new THREE.BufferGeometry();&#10;        const positions = triangle.flatMap(v =&gt; [v.x, v.y, v.z]);&#10;        geometry.setAttribute(&#10;          &quot;position&quot;,&#10;          new THREE.BufferAttribute(new Float32Array(positions), 3),&#10;        );&#10;        geometry.computeVertexNormals();&#10;&#10;        allTriangles.push({ geometry, index: triangleIndex++ });&#10;      });&#10;    }&#10;&#10;    console.log(`[${new Date().toLocaleTimeString()}] Created ${allTriangles.length} total triangles`);&#10;    return allTriangles;&#10;  };&#10;&#10;  // Memoize triangles to avoid unnecessary recalculation&#10;  const triangles = useMemo(() =&gt; {&#10;    const tris = createOctahedronTriangles();&#10;    console.log(`[${new Date().toLocaleTimeString()}] triangles useMemo: count=`, tris.length);&#10;    return tris;&#10;  }, [regionDetails]);&#10;&#10;  // Calculate triangle adjacency for keyboard navigation (optimized)&#10;  const triangleAdjacency = useMemo(() =&gt; {&#10;    console.log(`[${new Date().toLocaleTimeString()}] triangleAdjacency useMemo: triangles.length=`, triangles.length);&#10;    // Helper to create a unique key for an edge (sorted vertex positions)&#10;    function edgeKey(a: number[], b: number[]) {&#10;      // Sort the two vertices lexicographically&#10;      const v1 = a.join(&quot;,&quot;);&#10;      const v2 = b.join(&quot;,&quot;);&#10;      return v1 &lt; v2 ? `${v1}|${v2}` : `${v2}|${v1}`;&#10;    }&#10;&#10;    // Build a map from edge key to triangle indices&#10;    const edgeMap = new Map&lt;string, number[]&gt;();&#10;    triangles.forEach(({ geometry }, triIdx) =&gt; {&#10;      const pos = geometry.attributes.position.array as Float32Array;&#10;      const verts = [&#10;        [pos[0], pos[1], pos[2]],&#10;        [pos[3], pos[4], pos[5]],&#10;        [pos[6], pos[7], pos[8]],&#10;      ];&#10;      // Each triangle has 3 edges&#10;      for (let i = 0; i &lt; 3; i++) {&#10;        const a = verts[i];&#10;        const b = verts[(i + 1) % 3];&#10;        const key = edgeKey(a, b);&#10;        if (!edgeMap.has(key)) edgeMap.set(key, []);&#10;        edgeMap.get(key)!.push(triIdx);&#10;      }&#10;    });&#10;&#10;    // Now, for each triangle, find neighbors (other triangles sharing an edge)&#10;    const adjacency = new Map&lt;number, number&gt;();&#10;    triangles.forEach(({ geometry }, triIdx) =&gt; {&#10;      const pos = geometry.attributes.position.array as Float32Array;&#10;      const verts = [&#10;        [pos[0], pos[1], pos[2]],&#10;        [pos[3], pos[4], pos[5]],&#10;        [pos[6], pos[7], pos[8]],&#10;      ];&#10;      const neighbors = new Set&lt;number&gt;();&#10;      for (let i = 0; i &lt; 3; i++) {&#10;        const a = verts[i];&#10;        const b = verts[(i + 1) % 3];&#10;        const key = edgeKey(a, b);&#10;        const tris = edgeMap.get(key)!;&#10;        tris.forEach(idx =&gt; {&#10;          if (idx !== triIdx) neighbors.add(idx);&#10;        });&#10;      }&#10;      adjacency.set(triIdx, Array.from(neighbors));&#10;    });&#10;    console.log(`[${new Date().toLocaleTimeString()}] Adjacency map created with ${adjacency.size} entries`);&#10;    return adjacency;&#10;  }, [triangles]);&#10;&#10;  // Helper function to check if two triangles share an edge (2 vertices)&#10;  function shareEdge(&#10;    tri1: THREE.BufferGeometry,&#10;    tri2: THREE.BufferGeometry,&#10;  ): boolean {&#10;    const pos1 = tri1.attributes.position.array as Float32Array;&#10;    const pos2 = tri2.attributes.position.array as Float32Array;&#10;&#10;    const vertices1 = [];&#10;    const vertices2 = [];&#10;&#10;    // Extract vertices from both triangles&#10;    for (let i = 0; i &lt; 9; i += 3) {&#10;      vertices1.push([pos1[i], pos1[i + 1], pos1[i + 2]]);&#10;      vertices2.push([pos2[i], pos2[i + 1], pos2[i + 2]]);&#10;    }&#10;&#10;    // Count shared vertices (vertices that are very close to each other)&#10;    let sharedVertices = 0;&#10;    const tolerance = 0.001;&#10;&#10;    for (const v1 of vertices1) {&#10;      for (const v2 of vertices2) {&#10;        const dx = Math.abs(v1[0] - v2[0]);&#10;        const dy = Math.abs(v1[1] - v2[1]);&#10;        const dz = Math.abs(v1[2] - v2[2]);&#10;&#10;        if (dx &lt; tolerance &amp;&amp; dy &lt; tolerance &amp;&amp; dz &lt; tolerance) {&#10;          sharedVertices++;&#10;          break; // Found a match, move to next vertex in vertices1&#10;        }&#10;      }&#10;    }&#10;&#10;    // Triangles share an edge if they have exactly 2 vertices in common&#10;    return sharedVertices === 2;&#10;  }&#10;&#10;  // Keyboard navigation and G key mode&#10;  useEffect(() =&gt; {&#10;    const handleKeyDown = (event: KeyboardEvent) =&gt; {&#10;      // Handle G key for selection mode toggle&#10;      if (event.key === 'g' || event.key === 'G') {&#10;        const selectedTriangles = Array.from(clickedTriangles);&#10;        if (selectedTriangles.length === 1) {&#10;          setSelectionMode(!selectionMode);&#10;          setHoveredTriangle(null); // Clear any hover when toggling&#10;          console.log(`Selection mode ${!selectionMode ? 'enabled' : 'disabled'} [${new Date().toLocaleTimeString()}]`);&#10;          event.preventDefault();&#10;          return;&#10;        }&#10;      }&#10;&#10;      // Only handle navigation if a triangle is selected and not in selection mode&#10;      if (selectionMode) return;&#10;&#10;      const selectedTriangles = Array.from(clickedTriangles);&#10;      if (selectedTriangles.length !== 1) return;&#10;&#10;      const currentTriangle = selectedTriangles[0];&#10;      const neighbors = triangleAdjacency.get(currentTriangle) || [];&#10;&#10;      if (neighbors.length === 0) return;&#10;&#10;      let nextTriangle: number | null = null;&#10;&#10;      // Since each triangle has exactly 3 neighbors, map keys to cycle through them&#10;      switch (event.key) {&#10;        case &quot;ArrowUp&quot;:&#10;        case &quot;w&quot;:&#10;        case &quot;W&quot;:&#10;          // Move to first neighbor&#10;          nextTriangle = neighbors[0];&#10;          break;&#10;        case &quot;ArrowDown&quot;:&#10;        case &quot;s&quot;:&#10;        case &quot;S&quot;:&#10;          // Move to second neighbor (if available)&#10;          nextTriangle =&#10;            neighbors[1] !== undefined ? neighbors[1] : neighbors[0];&#10;          break;&#10;        case &quot;ArrowLeft&quot;:&#10;        case &quot;a&quot;:&#10;        case &quot;A&quot;:&#10;          // Move to third neighbor (cycling back)&#10;          nextTriangle =&#10;            neighbors[2] !== undefined&#10;              ? neighbors[2]&#10;              : neighbors[neighbors.length - 1];&#10;          break;&#10;        case &quot;ArrowRight&quot;:&#10;        case &quot;d&quot;:&#10;        case &quot;D&quot;:&#10;          // Cycle forward through neighbors (1 -&gt; 2 -&gt; 0 -&gt; 1...)&#10;          const currentIndex = neighbors.indexOf(currentTriangle);&#10;          let nextIndex = 0; // Default to first neighbor&#10;          if (currentIndex === -1) {&#10;            // If current triangle isn't in neighbors (shouldn't happen), use first neighbor&#10;            nextIndex = 0;&#10;          } else {&#10;            // Find which neighbor we came from and move to the next one&#10;            nextIndex =&#10;              neighbors.indexOf(&#10;                neighbors.find((n) =&gt; n &gt; currentTriangle) || neighbors[0],&#10;              ) % neighbors.length;&#10;          }&#10;          nextTriangle = neighbors[nextIndex];&#10;          break;&#10;        default:&#10;          return;&#10;      }&#10;&#10;      if (nextTriangle !== null) {&#10;        event.preventDefault();&#10;        console.log(&#10;          `[${new Date().toLocaleTimeString()}] Keyboard navigation: moving from triangle ${currentTriangle} to ${nextTriangle}`,&#10;        );&#10;        setClickedTriangles(new Set([nextTriangle]));&#10;      }&#10;    };&#10;&#10;    window.addEventListener(&quot;keydown&quot;, handleKeyDown);&#10;    return () =&gt; window.removeEventListener(&quot;keydown&quot;, handleKeyDown);&#10;  }, [clickedTriangles, triangleAdjacency, selectionMode]);&#10;&#10;  // Handle clicks on the group (background)&#10;  const handleClick = (event: THREE.Event) =&gt; {&#10;    // Disable selection mode when clicking anywhere&#10;    if (selectionMode) {&#10;      console.log('Disabling selection mode due to click [' + new Date().toLocaleTimeString() + ']');&#10;      setSelectionMode(false);&#10;    }&#10;  };&#10;&#10;  // Calculate triangle centers for pathfinding&#10;  const triangleCenters = useMemo(() =&gt; {&#10;    const centers = new Map&lt;number, THREE.Vector3&gt;();&#10;    triangles.forEach(({ geometry, index }) =&gt; {&#10;      const positions = geometry.attributes.position.array as Float32Array;&#10;      const center = new THREE.Vector3(&#10;        (positions[0] + positions[3] + positions[6]) / 3,&#10;        (positions[1] + positions[4] + positions[7]) / 3,&#10;        (positions[2] + positions[5] + positions[8]) / 3&#10;      );&#10;      centers.set(index, center);&#10;    });&#10;    return centers;&#10;  }, [triangles]);&#10;&#10;  // Pathfinding using BFS to find shortest path between triangles&#10;  const findPath = (start: number, end: number): number[] =&gt; {&#10;    if (start === end) return [start];&#10;&#10;    const queue: { triangle: number; path: number[] }[] = [{ triangle: start, path: [start] }];&#10;    const visited = new Set&lt;number&gt;([start]);&#10;&#10;    while (queue.length &gt; 0) {&#10;      const { triangle, path } = queue.shift()!;&#10;      const neighbors = triangleAdjacency.get(triangle) || [];&#10;&#10;      for (const neighbor of neighbors) {&#10;        if (neighbor === end) {&#10;          return [...path, neighbor];&#10;        }&#10;&#10;        if (!visited.has(neighbor)) {&#10;          visited.add(neighbor);&#10;          queue.push({ triangle: neighbor, path: [...path, neighbor] });&#10;        }&#10;      }&#10;    }&#10;&#10;    return []; // No path found&#10;  };&#10;&#10;  // Calculate path when in selection mode and hovering&#10;  const currentPath = useMemo(() =&gt; {&#10;    if (!selectionMode || hoveredTriangle === null) {&#10;      console.log(&quot;No path calculation - selectionMode:&quot;, selectionMode, &quot;hoveredTriangle:&quot;, hoveredTriangle);&#10;      return [];&#10;    }&#10;&#10;    const selectedTriangles = Array.from(clickedTriangles);&#10;    if (selectedTriangles.length !== 1) {&#10;      console.log(&quot;No path calculation - wrong selection count:&quot;, selectedTriangles.length);&#10;      return [];&#10;    }&#10;&#10;    const startTriangle = selectedTriangles[0];&#10;    if (startTriangle === hoveredTriangle) {&#10;      console.log(&quot;No path calculation - same triangle&quot;);&#10;      return [];&#10;    }&#10;&#10;    const path = findPath(startTriangle, hoveredTriangle);&#10;//     console.log(`Path calculated from ${startTriangle} to ${hoveredTriangle}:`, path);&#10;    return path;&#10;  }, [selectionMode, hoveredTriangle, clickedTriangles, triangleAdjacency]);&#10;&#10;  // Apply cursor style to canvas when in selection mode&#10;  useEffect(() =&gt; {&#10;    const canvas = document.querySelector('canvas');&#10;    if (canvas) {&#10;      canvas.style.cursor = selectionMode ? 'crosshair' : 'default';&#10;    }&#10;  }, [selectionMode]);&#10;&#10;  // Update line material resolution when window is resized&#10;  useEffect(() =&gt; {&#10;    const handleResize = () =&gt; {&#10;      if (lineRef.current &amp;&amp; lineRef.current.material) {&#10;        (lineRef.current.material as LineMaterial).resolution.set(&#10;          window.innerWidth, &#10;          window.innerHeight&#10;        );&#10;      }&#10;    };&#10;&#10;    window.addEventListener('resize', handleResize);&#10;    return () =&gt; {&#10;      window.removeEventListener('resize', handleResize);&#10;    };&#10;  }, []);&#10;&#10;  // Memoize path rendering function&#10;  const renderPath = useMemo(() =&gt; {&#10;    if (!selectionMode || hoveredTriangle === null || clickedTriangles.size !== 1) {&#10;      return null;&#10;    }&#10;&#10;    const selectedTriangle = Array.from(clickedTriangles)[0];&#10;    const path = findPath(selectedTriangle, hoveredTriangle);&#10;&#10;    if (path.length &gt; 1) {&#10;      // Debug: Log the path and corresponding centers&#10;      console.log(`[${new Date().toLocaleTimeString()}] Path indices:`, path);&#10;      const pathPoints = path.map(triangleIndex =&gt; {&#10;        const center = triangleCenters.get(triangleIndex);&#10;        if (!center) {&#10;          console.warn(`[${new Date().toLocaleTimeString()}] No center for triangleIndex`, triangleIndex);&#10;        }&#10;        return center ? center.clone().normalize().multiplyScalar(2.05) : new THREE.Vector3(0, 0, 0);&#10;      });&#10;      console.log(`[${new Date().toLocaleTimeString()}] Path points:`, pathPoints);&#10;&#10;      const positions: number[] = [];&#10;      pathPoints.forEach(point =&gt; {&#10;        positions.push(point.x, point.y, point.z);&#10;      });&#10;&#10;      const geometry = new LineGeometry();&#10;      geometry.setPositions(positions);&#10;&#10;      return (&#10;        &lt;primitive&#10;          object={new Line2(geometry,&#10;            new LineMaterial({&#10;              color: &quot;#ff4444&quot;,&#10;              linewidth: 3,&#10;              resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)&#10;            })&#10;          )}&#10;          ref={lineRef}&#10;        /&gt;&#10;      );&#10;    }&#10;    return null;&#10;  }, [selectionMode, hoveredTriangle, clickedTriangles, triangleCenters, findPath]);&#10;&#10;  return (&#10;    &lt;group&#10;      ref={groupRef}&#10;      position={[0, 0, 0]}&#10;      onClick={handleClick}&#10;      onPointerOver={() =&gt; setHovered(true)}&#10;      onPointerOut={() =&gt; setHovered(false)}&#10;    &gt;&#10;      {renderPath}&#10;&#10;      {faces.map((face, i) =&gt; (&#10;        &lt;OctahedronRegion&#10;          key={i}&#10;          baseVertices={[baseVerts[face[0]], baseVerts[face[1]], baseVerts[face[2]]]}&#10;          detail={regionDetails[i] || 0}&#10;          regionIndex={i}&#10;          onTriangleClick={(idx) =&gt; {&#10;            console.log(`[${new Date().toLocaleTimeString()}] OctahedronRegion onTriangleClick: regionIndex=`, i, 'triangleIndex=', idx);&#10;            handleTriangleClick(idx);&#10;          }}&#10;          selectedTriangles={clickedTriangles}&#10;          selectionMode={selectionMode}&#10;          hoveredTriangle={hoveredTriangle}&#10;          setHoveredTriangle={setHoveredTriangle}&#10;        /&gt;&#10;      ))}&#10;    &lt;/group&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client/src/components/OctahedronRegion.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/components/OctahedronRegion.tsx" />
              <option name="originalContent" value="import { useMemo } from &quot;react&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;export default function OctahedronRegion({&#10;  baseVertices,&#10;  detail,&#10;  regionIndex,&#10;  onTriangleClick,&#10;  selectedTriangles,&#10;  selectionMode,&#10;  hoveredTriangle,&#10;  setHoveredTriangle,&#10;}: {&#10;  baseVertices: [THREE.Vector3, THREE.Vector3, THREE.Vector3];&#10;  detail: number;&#10;  regionIndex: number;&#10;  onTriangleClick: (triangleIndex: number) =&gt; void;&#10;  selectedTriangles: Set&lt;number&gt;;&#10;  selectionMode: boolean;&#10;  hoveredTriangle: number | null;&#10;  setHoveredTriangle: (idx: number | null) =&gt; void;&#10;}) {&#10;  // Subdivide a triangle into 4 smaller triangles&#10;  function subdivideTriangle(&#10;    v1: THREE.Vector3,&#10;    v2: THREE.Vector3,&#10;    v3: THREE.Vector3,&#10;    level: number,&#10;  ): THREE.Vector3[][] {&#10;    if (level === 0) {&#10;      return [[v1, v2, v3]];&#10;    }&#10;    const m1 = new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5).normalize().multiplyScalar(2);&#10;    const m2 = new THREE.Vector3().addVectors(v2, v3).multiplyScalar(0.5).normalize().multiplyScalar(2);&#10;    const m3 = new THREE.Vector3().addVectors(v3, v1).multiplyScalar(0.5).normalize().multiplyScalar(2);&#10;    return [&#10;      ...subdivideTriangle(v1, m1, m3, level - 1),&#10;      ...subdivideTriangle(m1, v2, m2, level - 1),&#10;      ...subdivideTriangle(m3, m2, v3, level - 1),&#10;      ...subdivideTriangle(m1, m2, m3, level - 1),&#10;    ];&#10;  }&#10;&#10;  // Generate triangles for this region&#10;  const triangles = useMemo(() =&gt; {&#10;    // Ensure vertices are normalized to exact same position&#10;    const normalizeVertex = (v: THREE.Vector3) =&gt; {&#10;      return v.normalize().multiplyScalar(2);&#10;    };&#10;&#10;    // Normalize input vertices to ensure consistent positions at shared edges&#10;    const v1 = normalizeVertex(baseVertices[0].clone());&#10;    const v2 = normalizeVertex(baseVertices[1].clone());&#10;    const v3 = normalizeVertex(baseVertices[2].clone());&#10;&#10;    return subdivideTriangle(v1, v2, v3, detail);&#10;  }, [baseVertices, detail]);&#10;&#10;  // Create all geometries at once&#10;  const geometries = useMemo(() =&gt; {&#10;    // Function to ensure consistent vertex positions&#10;    const snapToSphere = (x: number, y: number, z: number) =&gt; {&#10;      const len = Math.sqrt(x * x + y * y + z * z);&#10;      // Ensure exactly length 2 (radius of sphere)&#10;      return [&#10;        (x / len) * 2,&#10;        (y / len) * 2,&#10;        (z / len) * 2&#10;      ];&#10;    };&#10;&#10;    return triangles.map(triangle =&gt; {&#10;      // Snap all vertices exactly to the sphere surface&#10;      const [x1, y1, z1] = snapToSphere(triangle[0].x, triangle[0].y, triangle[0].z);&#10;      const [x2, y2, z2] = snapToSphere(triangle[1].x, triangle[1].y, triangle[1].z);&#10;      const [x3, y3, z3] = snapToSphere(triangle[2].x, triangle[2].y, triangle[2].z);&#10;&#10;      const positions = [&#10;        x1, y1, z1,&#10;        x2, y2, z2,&#10;        x3, y3, z3,&#10;      ];&#10;      const geom = new THREE.BufferGeometry();&#10;      geom.setAttribute(&quot;position&quot;, new THREE.BufferAttribute(new Float32Array(positions), 3));&#10;      geom.computeVertexNormals();&#10;      return geom;&#10;    });&#10;  }, [triangles]);&#10;&#10;  return (&#10;    &lt;group&gt;&#10;      {geometries.map((geometry, i) =&gt; {&#10;        const triangleIndex = regionIndex * 100000 + i; // Unique index per region&#10;        return (&#10;          &lt;mesh&#10;            key={triangleIndex}&#10;            geometry={geometry}&#10;            castShadow&#10;            receiveShadow&#10;            onClick={(e) =&gt; {&#10;              e.stopPropagation();&#10;              onTriangleClick(triangleIndex);&#10;            }}&#10;            onPointerOver={(e) =&gt; {&#10;              e.stopPropagation();&#10;              selectionMode &amp;&amp; setHoveredTriangle(triangleIndex)&#10;            }}&#10;            onPointerOut={(e) =&gt; {&#10;              e.stopPropagation();&#10;              selectionMode &amp;&amp; setHoveredTriangle(null)&#10;            }}&#10;          &gt;&#10;            &lt;meshStandardMaterial&#10;              color={&#10;                selectedTriangles.has(triangleIndex)&#10;                  ? &quot;#ff6b6b&quot;&#10;                  : selectionMode &amp;&amp; hoveredTriangle === triangleIndex&#10;                  ? &quot;#ffff00&quot;&#10;                  : &quot;#45b7d1&quot;&#10;              }&#10;              wireframe={false}&#10;              metalness={0.3}&#10;              roughness={0.4}&#10;              side={THREE.DoubleSide}&#10;            /&gt;&#10;          &lt;/mesh&gt;&#10;        );&#10;      })}&#10;    &lt;/group&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import { useMemo } from &quot;react&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;export default function OctahedronRegion({&#10;  baseVertices,&#10;  detail,&#10;  regionIndex,&#10;  onTriangleClick,&#10;  selectedTriangles,&#10;  selectionMode,&#10;  hoveredTriangle,&#10;  setHoveredTriangle,&#10;}: {&#10;  baseVertices: [THREE.Vector3, THREE.Vector3, THREE.Vector3];&#10;  detail: number;&#10;  regionIndex: number;&#10;  onTriangleClick: (triangleIndex: number) =&gt; void;&#10;  selectedTriangles: Set&lt;number&gt;;&#10;  selectionMode: boolean;&#10;  hoveredTriangle: number | null;&#10;  setHoveredTriangle: (idx: number | null) =&gt; void;&#10;}) {&#10;  // Subdivide a triangle into 4 smaller triangles&#10;  function subdivideTriangle(&#10;    v1: THREE.Vector3,&#10;    v2: THREE.Vector3,&#10;    v3: THREE.Vector3,&#10;    level: number,&#10;  ): THREE.Vector3[][] {&#10;    if (level === 0) {&#10;      return [[v1, v2, v3]];&#10;    }&#10;    const m1 = new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5).normalize().multiplyScalar(2);&#10;    const m2 = new THREE.Vector3().addVectors(v2, v3).multiplyScalar(0.5).normalize().multiplyScalar(2);&#10;    const m3 = new THREE.Vector3().addVectors(v3, v1).multiplyScalar(0.5).normalize().multiplyScalar(2);&#10;    return [&#10;      ...subdivideTriangle(v1, m1, m3, level - 1),&#10;      ...subdivideTriangle(m1, v2, m2, level - 1),&#10;      ...subdivideTriangle(m3, m2, v3, level - 1),&#10;      ...subdivideTriangle(m1, m2, m3, level - 1),&#10;    ];&#10;  }&#10;&#10;  // Generate triangles for this region&#10;  const triangles = useMemo(() =&gt; {&#10;    // Ensure vertices are normalized to exact same position&#10;    const normalizeVertex = (v: THREE.Vector3) =&gt; {&#10;      return v.normalize().multiplyScalar(2);&#10;    };&#10;&#10;    // Normalize input vertices to ensure consistent positions at shared edges&#10;    const v1 = normalizeVertex(baseVertices[0].clone());&#10;    const v2 = normalizeVertex(baseVertices[1].clone());&#10;    const v3 = normalizeVertex(baseVertices[2].clone());&#10;&#10;    return subdivideTriangle(v1, v2, v3, detail);&#10;  }, [baseVertices, detail]);&#10;&#10;  // Create all geometries at once&#10;  const geometries = useMemo(() =&gt; {&#10;    // Function to ensure consistent vertex positions&#10;    const snapToSphere = (x: number, y: number, z: number) =&gt; {&#10;      const len = Math.sqrt(x * x + y * y + z * z);&#10;      // Ensure exactly length 2 (radius of sphere)&#10;      return [&#10;        (x / len) * 2,&#10;        (y / len) * 2,&#10;        (z / len) * 2&#10;      ];&#10;    };&#10;&#10;    return triangles.map(triangle =&gt; {&#10;      // Snap all vertices exactly to the sphere surface&#10;      const [x1, y1, z1] = snapToSphere(triangle[0].x, triangle[0].y, triangle[0].z);&#10;      const [x2, y2, z2] = snapToSphere(triangle[1].x, triangle[1].y, triangle[1].z);&#10;      const [x3, y3, z3] = snapToSphere(triangle[2].x, triangle[2].y, triangle[2].z);&#10;&#10;      const positions = [&#10;        x1, y1, z1,&#10;        x2, y2, z2,&#10;        x3, y3, z3,&#10;      ];&#10;      const geom = new THREE.BufferGeometry();&#10;      geom.setAttribute(&quot;position&quot;, new THREE.BufferAttribute(new Float32Array(positions), 3));&#10;      geom.computeVertexNormals();&#10;      return geom;&#10;    });&#10;  }, [triangles]);&#10;&#10;  return (&#10;    &lt;group&gt;&#10;      {geometries.map((geometry, i) =&gt; {&#10;        const triangleIndex = regionIndex * 100000 + i; // Unique index per region&#10;        return (&#10;          &lt;mesh&#10;            key={triangleIndex}&#10;            geometry={geometry}&#10;            castShadow&#10;            receiveShadow&#10;            onClick={(e) =&gt; {&#10;              e.stopPropagation();&#10;              onTriangleClick(triangleIndex);&#10;            }}&#10;            onPointerOver={(e) =&gt; {&#10;              e.stopPropagation();&#10;              selectionMode &amp;&amp; setHoveredTriangle(triangleIndex)&#10;            }}&#10;            onPointerOut={(e) =&gt; {&#10;              e.stopPropagation();&#10;              selectionMode &amp;&amp; setHoveredTriangle(null)&#10;            }}&#10;          &gt;&#10;            &lt;meshStandardMaterial&#10;              color={&#10;                selectedTriangles.has(triangleIndex)&#10;                  ? &quot;#ff6b6b&quot;&#10;                  : selectionMode &amp;&amp; hoveredTriangle === triangleIndex&#10;                  ? &quot;#ffff00&quot;&#10;                  : &quot;#45b7d1&quot;&#10;              }&#10;              wireframe={false}&#10;              metalness={0.3}&#10;              roughness={0.4}&#10;              side={THREE.DoubleSide}&#10;            /&gt;&#10;          &lt;/mesh&gt;&#10;        );&#10;      })}&#10;    &lt;/group&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>